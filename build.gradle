/*
 * Copyright (c) 2025 cpmn.tech
 *
 * Licensed under the MIT License.
 * You may obtain a copy of the License at
 * https://opensource.org/licenses/MIT
 *
 * This file is part of the VulcanTestFramework project.
 * A QA Automation Project by Claudia Paola Muñoz (cpmn.tech)
 */

  
plugins {
    id 'java'
    id 'io.qameta.allure' version '3.0.1'
}

group = 'com.vulcan'
version = '0.1.0-SNAPSHOT'

repositories {
    mavenCentral()
}
import io.qameta.allure.gradle.report.tasks.AllureReport
import io.qameta.allure.gradle.report.tasks.AllureServe

//Centralize suite names/constants
ext {
    allureVersion = "2.32.0"

    cucumberRunner = "com.vulcan.framework.runners.CucumberTestRunner"

    suites = [
        ui : [
            id          : "ui",
            label       : "UI",
            featuresDir : "src/test/resources/features/ui",
            testTask    : "uiTest",
            resultsConf : "allureResultsUi"
        ],
        api: [
            id          : "api",
            label       : "API",
            featuresDir : "src/test/resources/features/api",
            testTask    : "apiTest",
            resultsConf : "allureResultsApi"
        ],
        all: [
            id          : "all",
            label       : "ALL",
            featuresDir : "src/test/resources/features",
            testTask    : "test",
            resultsConf : "allureResultsAll"
        ]
    ]
}

configurations {
    allureResultsUi
    allureResultsApi
    allureResultsAll
}
configurations.configureEach {
    resolutionStrategy.eachDependency { details ->
        if (details.requested.group == "io.qameta.allure") {
            details.useVersion(allureVersion)
            details.because("Align Allure adapters with Allure commandline ${allureVersion}")
        }
    }
}
// Allure Gradle adapter is not configuration-cache friendly (it touches Task.project at execution time).
// We disable configuration cache only for test execution tasks.
tasks.withType(Test).configureEach {
    notCompatibleWithConfigurationCache("Allure adapter is not compatible with Gradle configuration cache for Test tasks.")
}
tasks.withType(AllureReport).configureEach {
    notCompatibleWithConfigurationCache("Allure report tasks are not configuration-cache compatible.")
}

tasks.withType(AllureServe).configureEach {
    notCompatibleWithConfigurationCache("Allure serve tasks are not configuration-cache compatible.")
}

dependencies {
    // Base test framework (JUnit 4)
    testImplementation 'junit:junit:4.13.2'

    // Selenium WebDriver
    testImplementation 'org.seleniumhq.selenium:selenium-java:4.20.0'

    // Cucumber JVM (Java + JUnit)
    testImplementation 'io.cucumber:cucumber-java:7.15.0'
    testImplementation 'io.cucumber:cucumber-junit:7.15.0'

    // WebDriverManager (automatic driver downloads)
    testImplementation 'io.github.bonigarcia:webdrivermanager:5.7.0'

    // Logging - Log4j2
    testImplementation 'org.apache.logging.log4j:log4j-api:2.24.0'
    testImplementation 'org.apache.logging.log4j:log4j-core:2.24.0'
    // SLF4J -> Log4j2 bridge (fixes "No SLF4J providers were found")
    testImplementation 'org.apache.logging.log4j:log4j-slf4j2-impl:2.24.0'
    
    // API Testing - RestAssured
    testImplementation 'io.rest-assured:rest-assured:5.5.0'
    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.18.2'

}

// Tell Allure plugin where raw results live (as configurations)
["ui", "api", "all"].each { suite ->
    dependencies.add("allureResults${suite.capitalize()}",
        files("$buildDir/allure-results/${suite}")
    )
}

allure {
    // Allure commandline version used by the report/serve tasks
    version.set(allureVersion)

    report {
        // Where HTML report is generated (optional customization)
        // reportDir.set(layout.buildDirectory.dir("reports/allure"))
        // singleFile.set(true) // optional
        dependsOnTests.set(false) // keep false; you already run apiTest/uiTest explicitly
    }
}

/* =============== Helpers =============== */

/**
 * Enables build-script debug logs when running with:
 *   ./gradlew <task> -Pdebug
 */
def debugBuild = project.hasProperty("debug")

 /**
 * Applies common framework-level system properties and test configuration
 * to a Gradle Test task.
 *
 * Responsibilities:
 * 1. Expose values from gradle.properties as JVM system properties
 *    so they can be consumed by the framework (ConfigManager).
 * 2. Forward Cucumber CLI filters (e.g. -Dcucumber.filter.tags)
 *    from the Gradle daemon to the test JVM.
 * 3. Configure consistent logging and execution behavior.
 *
 * This helper MUST be applied to all Test tasks (test, apiTest, uiTest)
 * to guarantee deterministic behavior across environments and CI.
 */
def applyFrameworkSystemProps = { Test t ->
    
    /*
     * Map framework configuration keys from gradle.properties
     * into JVM system properties.
     *
     * Example:
     *   gradle.properties → ui.baseUrl=https://example.com
     *   JVM               → System.getProperty("ui.baseUrl")
     */
    [
        'ui.baseUrl',
        'ui.browser',
        'ui.implicitWait',
        'api.baseUrl',
        'api.timeout',
        'env'
    ].each { key ->
        if (project.hasProperty(key)) {
            t.systemProperty key, project.property(key)
        }
    }

    /*
     * Configure console output for test execution.
     * This improves local debugging and CI logs.
     */
    t.testLogging {
        events "PASSED", "FAILED", "SKIPPED"
        showStandardStreams = true
    }

    /*
     * Explicitly use JUnit (required by Cucumber-JUnit).
     */
    t.useJUnit()
    
    /*
     * Allow Gradle to succeed even if no tests are discovered.
     * This is important for folder-based execution
     * (e.g. running apiTest when no API features exist yet).
     */ 
    t.failOnNoDiscoveredTests = false

    /*
     * Forward Cucumber tag filters provided via CLI:
     *
     *   ./gradlew test -Dcucumber.filter.tags="@api"
     *
     * Without this, Gradle would NOT pass the tag filter
     * to the test JVM and Cucumber would execute all scenarios.
     */
    def tags = System.getProperty("cucumber.filter.tags")
    if (tags != null) {
        t.systemProperty("cucumber.filter.tags", tags)
    }
}

/**
 * Configures Cucumber + Allure reporting for a suite ("api", "ui", "all").
 *
 * Responsibilities:
 * 1) Set Allure results directory per suite (build/allure-results/<suite>).
 * 2) Create suite report folders before execution (doFirst).
 * 3) Configure Cucumber plugins (pretty, Allure adapter, JSON, JUnit).
 *
 * This prevents report outputs from overwriting each other across suites.
 */
/* def configureCucumberReporting = { Test t, String suite ->

   if (debugBuild) {
        logger.lifecycle("[Cucumber-DEBUG] Configuring reporting")
        logger.lifecycle("[Cucumber-DEBUG] Task name : ${t.name}")
        logger.lifecycle("[Cucumber-DEBUG] Suite     : ${suite}")
        logger.lifecycle("[Cucumber-DEBUG] Allure dir: ${buildDir}/allure-results/${suite}")
    }

    // Allure results directory (separate per suite)
    t.systemProperty "allure.results.directory", "${buildDir}/allure-results/${suite}"

    // Ensure output folder exists for cucumber.json (avoid folder-not-found issues on some systems)
    t.doFirst {
        if (debugBuild) {
            logger.lifecycle("[Cucumber-DEBUG] doFirst() for task=${t.name}, suite=${suite}")
        }
        file("${buildDir}/reports/cucumber/${suite}").mkdirs()
        file("${buildDir}/allure-results/${suite}").mkdirs()
    }

    // Cucumber plugins:
    // - pretty: readable console output
    // - Allure adapter: produces allure-results
    // - json: machine-readable cucumber report (KPIs / CI / debugging)
    // - junit: CI-friendly output
    t.systemProperty "cucumber.plugin",
            "pretty," +    
            "io.qameta.allure.cucumber7jvm.AllureCucumber7Jvm," +        
            "json:${buildDir}/reports/cucumber/${suite}/cucumber.json," +
            "junit:${buildDir}/reports/cucumber/${suite}/cucumber.xml"
} */

def configureCucumberReporting = { Test t, String suite ->

    // Use Gradle's layout API (configuration-cache friendly)
    def cucumberDir = layout.buildDirectory.dir("reports/cucumber/${suite}").get().asFile
    def allureDir   = layout.buildDirectory.dir("allure-results/${suite}").get().asFile

    // Create directories during configuration (NOT at task execution time)
    cucumberDir.mkdirs()
    allureDir.mkdirs()

    // Allure results directory (separate per suite)
    t.systemProperty "allure.results.directory", allureDir.absolutePath

    // Cucumber plugins:
    // - pretty: readable console output
    // - Allure adapter: produces allure results
    // - json: machine-readable cucumber report
    // - junit: CI-friendly output
    t.systemProperty "cucumber.plugin",
            "pretty," +
            "io.qameta.allure.cucumber7jvm.AllureCucumber7Jvm," +
            "json:${new File(cucumberDir, "cucumber.json").absolutePath}," +
            "junit:${new File(cucumberDir, "cucumber.xml").absolutePath}"
}


/**
 * Registers a dedicated Cucumber suite as a Gradle Test task (e.g., apiTest, uiTest).
 *
 * Responsibilities:
 * 1) Create a Gradle Test task with consistent framework settings.
 * 2) Ensure test classes are compiled before execution.
 * 3) Limit execution to the single Cucumber JUnit runner to prevent Gradle
 *    from attempting to execute step definition classes directly.
 * 4) Set feature discovery to a specific folder (suite isolation).
 * 5) Configure suite-specific Cucumber + Allure reporting output directories.
 *
 * Parameters:
 * - taskName:      Name of the Gradle task to register (e.g., "apiTest").
 * - suite:         Suite identifier used for report folder names (e.g., "api", "ui").
 * - featuresPath:  Path to the feature folder for this suite.
 * - descriptionText: Human-readable task description.
 */
def registerCucumberSuiteTask = { String taskName, String suite, String featuresPath, String descriptionText ->
    tasks.register(taskName, Test) { Test t ->
        group = "verification"
        description = descriptionText

        // Apply shared framework configuration (gradle.properties -> system properties, logging, tag forwarding)
        applyFrameworkSystemProps(t)

        // Ensure test classes are compiled before executing this suite.
        dependsOn(tasks.named("testClasses"))

        // Explicit test output and runtime classpath required for custom Test tasks.
        testClassesDirs = sourceSets.test.output.classesDirs
        classpath = sourceSets.test.runtimeClasspath

        // Restrict execution to the Cucumber JUnit runner only.
        filter {
            includeTestsMatching(cucumberRunner)
        }

        // Folder-based feature discovery for deterministic suite execution.
        systemProperty("cucumber.features", featuresPath)

        // Configure suite-specific Cucumber + Allure reporting outputs.
        configureCucumberReporting(t, suite)
    }
}

def baseAllureServe = tasks.named("allureServe", AllureServe)
/**
 * Registers an AllureServe task for a specific test suite (UI, API, etc.).
 *
 * Responsibilities:
 * 1) Serve an Allure HTML report for a single suite.
 * 2) Ensure the corresponding test suite is executed before serving.
 * 3) Reuse the Allure CLI configuration from the plugin-created task.
 * 4) Point Allure to the correct suite-specific results directory.
 *
 * Parameters:
 * - taskName:        Name of the Gradle task (e.g., "allureServeUi").
 * - suiteName:       Human-readable suite name for descriptions.
 * - testTaskName:    Test task that must run before serving (e.g., "uiTest").
 * - resultsConfig:   Configuration containing the Allure results directory.
 */
def registerAllureServeTask = { 
        String taskName,
        String suiteName,
        String testTaskName,
        Configuration resultsConfig ->

    tasks.register(taskName, AllureServe) {
        group = "verification"
        description = "Serves Allure report for ${suiteName} suite."

        dependsOn(testTaskName, "downloadAllure")

        // Reuse CLI wiring from plugin-created allureServe task
        allureHome.set(baseAllureServe.flatMap { it.allureHome })
        allureExecutable.set(baseAllureServe.flatMap { it.allureExecutable })

        // Point Allure to suite-specific results
        resultsDirs = resultsConfig

        notCompatibleWithConfigurationCache(
            "Allure serve uses downloaded CLI and dynamic inputs."
        )
    }
}
/**
 * Registers an AllureReport task for a specific test suite (UI, API, etc.).
 *
 * Responsibilities:
 * 1) Generate a static Allure HTML report for a single suite.
 * 2) Ensure the corresponding test suite is executed before report generation.
 * 3) Reuse the Allure CLI configuration from the plugin-created task.
 * 4) Isolate report output per suite to avoid overwrites.
 *
 * Parameters:
 * - taskName:        Name of the Gradle task (e.g., "allureReportUi").
 * - suiteName:       Human-readable suite name for descriptions.
 * - testTaskName:    Test task that must run before report generation.
 * - resultsConfig:   Configuration containing the Allure results directory.
 * - reportDirName:   Folder name under build/reports/allure/.
 */
def registerAllureReportTask = {
        String taskName,
        String suiteName,
        String testTaskName,
        Configuration resultsConfig,
        String reportDirName ->

    tasks.register(taskName, AllureReport) {
        group = "verification"
        description = "Generates Allure HTML report for ${suiteName} suite."

        dependsOn(testTaskName, "downloadAllure")

        // Reuse CLI wiring from plugin-created AllureReport task
        allureHome.set(baseAllureServe.flatMap { it.allureHome })
        allureExecutable.set(baseAllureServe.flatMap { it.allureExecutable })

        // Suite-specific inputs & outputs
        resultsDirs = resultsConfig
        reportDir.set(layout.buildDirectory.dir("reports/allure/${reportDirName}"))

        notCompatibleWithConfigurationCache(
            "Allure report uses downloaded CLI and dynamic inputs."
        )
    }
}



/* ===== Tasks ===== */



tasks.register("allTests") {
    group = "verification"
    description = "Runs UI + API test suites."
    dependsOn("uiTest", "apiTest")
}

/**
 * Default Gradle test task to execute ALL Cucumber scenarios
 * (both UI and API) in a single run.
 *
 * Key responsibilities:
 * - Discover and execute all feature files under src/test/resources/features
 * - Support CLI overrides for feature paths and tag filtering
 * - Apply shared framework configuration consistently
 * - Generate combined Cucumber reports under build/reports/cucumber/all
 *
 * This task is intended for:
 * - Local full regression runs
 * - Quick sanity checks
 * - Scenarios where a single, combined report is sufficient
 *
 * NOTE:
 * - UI vs API execution logic is still handled dynamically by Hooks
 *   (API scenarios skip browser setup automatically).
 * - For CI pipelines, apiTest and uiTest tasks are preferred.
 */
tasks.named('test', Test) { Test t ->

    /*
     * Apply shared framework configuration:
     * - Maps gradle.properties values into JVM system properties
     * - Forwards Cucumber tag filters (-Dcucumber.filter.tags)
     * - Configures logging and execution behavior
     */
    applyFrameworkSystemProps(t)

    /*
     * Feature discovery strategy:
     *
     * 1. If the user provides a custom feature path via CLI:
     *      -Dcucumber.features=src/test/resources/features/api/user.feature
     *
     *    → Only those features are executed.
     *
     * 2. Otherwise, default to discovering ALL features:
     *      src/test/resources/features
     *
     * This provides maximum flexibility without requiring
     * changes to the build script.
     */
    def featurePath = System.getProperty("cucumber.features")
    t.systemProperty(
        "cucumber.features",
        featurePath ?: "src/test/resources/features"
    )

    /*
     * Configure combined Cucumber reporting.
     *
     * Outputs are written to:
     *   build/reports/cucumber/all/
     *
     * This includes:
     * - cucumber.html  → human-readable report
     * - cucumber.json  → machine-readable (KPIs, trends, CI)
     * - cucumber.xml   → CI-friendly JUnit format
     */
    configureCucumberReporting(t, "all")
}

["ui", "api"].each { s ->
    def suite = suites[s]

    registerCucumberSuiteTask(
        suite.testTask,
        suite.id,
        suite.featuresDir,
        "Runs ${suite.label} Cucumber features only (${suite.featuresDir})."
    )

    registerAllureServeTask(
        "allureServe${suite.label}",
        suite.label,
        suite.testTask,
        configurations.named(suite.resultsConf).get()
    )

    registerAllureReportTask(
        "allureReport${suite.label}",
        suite.label,
        suite.testTask,
        configurations.named(suite.resultsConf).get(),
        suite.id
    )
}

tasks.named("uiTest", Test).configure { Test t ->
    // We want Allure to open even if some tests fail
    // (especially useful during debugging)
    ignoreFailures = true
}




